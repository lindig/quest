%
% $Id: main.nw 3 2006-04-29 13:17:19Z lindig $
%
Filename
\section{Main}

This is the top-level module of the application. It exports nothing but
evaluates the command line arguments and gets everything started.

<<main.mli>>=
val main: unit -> unit     (* is executed automatically *)
@

\implementation{Implementation}

<<main.ml>>=
module P  = Pretty
module PC = Ppcee
module R  = Rtype
module S  = Strategy
module I  = Lualink.I
module V  = I.Value

exception Error   of string
exception CmdLine of string
let error   fmt = Printf.kprintf (fun msg -> raise (Error msg)) fmt
let cmdline msg = raise (CmdLine msg)
let printf      = Printf.printf
let sprintf     = Printf.sprintf
let version     = "$Id: main.nw 3 2006-04-29 13:17:19Z lindig $"
let (@@) f x    = f x

@

\paragraph{Command Line Options} We export the actual command line and
options into the Lua table [[CMD]].

<<main.ml>>=
type eval = 
    | String of string
    | File   of string

type options =
    { mutable n:        int (* number of test cases *)
    ; mutable size:     int (* size per test case   *)
    ; mutable out:      string (* file name for -m output *)
    ; mutable gen:      string (* name of type generator *)
    ; mutable stereo:   bool (* generate one or two files? *)
    ; mutable seed:     int option (* seed for Random *)
    ; mutable eval:     eval list
    }

let defaults =
    { n         = 20
    ; size      = 2
    ; out       = "quest"
    ; gen       = "ansi"
    ; stereo    = false
    ; eval      = []
    ; seed      = None
    }

let export_options lua opts =
    let int     = V.int.V.embed          in
    let str     = V.string.V.embed       in
    let bool    = V.bool.V.embed         in
    let argv    = Array.to_list Sys.argv in
        I.register_module "CMD"
        [ "n",          int  opts.n
        ; "size",       int  opts.size
        ; "out",        str  opts.out
        ; "gen",        str  opts.gen
        ; "stereo",     bool opts.stereo
        ; "argv",       (V.list V.string).V.embed (List.tl argv)
        ; "argstr",     V.string.V.embed          (String.concat " " argv)  
        ; "cmd",        V.string.V.embed          (List.hd argv)
        ] lua
@

\paragraph{Command Line Parsing}

Function [[init_prg]] initializes the pseudo-random generator; it uses
either a user-supplied seed (to aid debugging) or an automatically
chosen one.

<<main.ml>>=
let init_prg seed = 
    ( match seed with 
    | None   -> (Random.self_init (); Prg.init (Random.int 12345))
    | Some x -> (Random.init x      ; Prg.init x)
    )
    
 
let synopsis this =
    [ "usage: "^this^" [options]" 
    ; ""
    ; "-n 123           123 test cases per file (default: 20)"
    ; "-s 3             size per test case (default: 2)"
    ; "-1               generate stand-alone file to stdout (default)"
    ; "-2               generate two files: quest-main.c, quest-callee.c"
    ; "-o name          use 'name' instead of 'quest' for output files"
    ; "-test x          use test suite x; there are predefined test suites:"
    ; "-list            list available test suites on stdout"
    ; "-seed 12345      seed the random-number generator with 12345"
    ; ""
    ; "file.lua         load file.lua into Lua interpreter, may be repeated"
    ; "-lua             dump default Lua code to stdout"
    ; "x=y              assign y to variable x in Lua interpreter"
    ; "-e chunk         evaluate lua code chunk, may be repeated"
    ; "-i               drop into interactive Lua interpreter"
    ; "-try gen         print types generated by generator gen"
    ; ""
    ; "-h, -help        offer minimal help on stdout"
    ; "-man             emit manual page to stdout (contains LICENSE)"
    ; "-version         identify version of this tool on stdout"
    ; ""
    ; "Author: Christian Lindig http://www.st.cs.uni-sb.de/~lindig/"
    ]
    
let usage this msg =
    List.iter prerr_endline (synopsis this @ ["diagnosis: "^msg])

let help this = 
    List.iter print_endline (synopsis this)

let version this =
    List.iter print_endline
    [ this^" version $Id: main.nw 3 2006-04-29 13:17:19Z lindig $"
    ; "(c) 2004, 2005 Christian Lindig <lindig@cs.uni-sb.de>"
    ; "compiled on "^Luacode.date
    ]
      
let int str =
    try int_of_string str
    with Failure _ -> cmdline ("not a number: "^str) 

let eval lua = function
    | String s -> I.dostring lua s
    | File   s -> I.dofile lua s

<<main.ml>>=
let doit opts =
    let ()  = init_prg opts.seed      in
    let lua = I.mk ()                 in
        ( export_options lua opts
        ; ignore @@ I.dostring lua Luacode.quest
        ; List.iter (fun x -> ignore @@ eval lua x) (List.rev opts.eval)
        )

let main () =
    let argv    = Array.to_list Sys.argv in
    let this    = Filename.basename (List.hd argv) in
    let args    = List.tl argv in
    let opts    = defaults in    
    let shell   = "Quest.shell()" in
    let main    = "Quest.main(CMD)" in
    let list    = "Quest.list_tests()" in
    let tryit s = sprintf "Quest.try(CMD,%s)" s in
    let load f = File f in 
    let exec s = String s in
    let rec parse = function
        | "-n" :: x     :: args -> opts.n    <- int x       ; parse args
        | "-s" :: x     :: args -> opts.size <- int x       ; parse args
        | "-seed" :: x  :: args -> opts.seed <- Some (int x); parse args
        | "-test" :: x  :: args -> opts.gen  <- x           ; parse args 
        | "-o" :: x     :: args -> opts.out  <- x           ; parse args
        | "-2"          :: args -> opts.stereo <- true      ; parse args   
        | "-1"          :: args -> opts.stereo <- false     ; parse args   
        | "-e"   :: x   :: args -> opts.eval <- exec x::opts.eval; parse args
        | "-i"          :: args -> opts.eval <- exec shell::opts.eval; doit opts
        | "-list"       :: args -> opts.eval <- exec list::opts.eval ; doit opts
        | "-try" :: x   :: args -> opts.eval <- exec (tryit x)::opts.eval; doit opts
        | "-lua"        :: []   -> print_endline Luacode.quest
        | "-man"        :: []   -> print_endline Luacode.manual
        | "-h"          :: []   -> help this
        | "-help"       :: []   -> help this
        | "-version"    :: []   -> version this
        | x             :: args when String.contains x '=' 
                                -> opts.eval <- exec x::opts.eval; parse args 
        | f             :: args when Filename.check_suffix f ".lua"
                                -> opts.eval <- load f::opts.eval; parse args
        | x             :: _    -> cmdline ("illegal command line argument "^x)
        | []                    -> opts.eval <- exec main::opts.eval; doit opts
        in              
            try parse args with CmdLine msg -> (usage this msg; exit 1)
@

Everything starts from here.

<<main.ml>>=
let () = main ()
@

